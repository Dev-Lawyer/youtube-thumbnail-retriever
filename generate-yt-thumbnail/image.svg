<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- 
  https://github.com/OctavioSI 

  Para acessar o artigo completo que utiliza este arquivo, acesse aqui: 
  üîó https://br.dev.lawyer/2021/10/mais-formas-personalizar-perfil-github-parte-2.html

  Este arquivo √© acessado diretamente do endere√ßo pelo browser, 
  e consiste em um c√≥digo para um arquivo SVG.  Em tese, conseguimos 
  usar esse SVG para alimentar um arquivo de imagem e poder√≠amos simplesmente
  passar como endere√ßo essa imagem e os par√¢metros necess√°rios para carregar 
  esse layout.
-->
<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width="250" height="220" viewBox="0 0 250 220" fill="none" id="svgfile">
	<style>
		@import url('https://fonts.googleapis.com/css2?family=Roboto');
	</style>
	<defs>
		<clipPath id="image-clip">
			<use xlink:href="#rect"/>
		</clipPath>
	</defs>
	<!-- Ret√¢ngulo container -->
	<rect id="rect" height="100%" width="100%" fill="#F9F9F9" />
	<!-- Thumbnail -->
	<g>
		<image href="" id="videoThumbnail" height="140" width="250" clip-path="url(#image-clip)" />
	</g>
	<!-- T√≠tulo do v√≠deo -->
  <g transform="translate(0, 135)">
    <!-- 
      Usamos aqui uma tag foreignObject pois ela possibilita que usemos CSS
      dentro do SVG (usamos o estilo para esse id #videoTitle na parte de 
      cima deste arquivo ‚òùÔ∏è)
    -->
    <foreignObject width="95%" height="100%">
      <style>
      /*
        Abaixo importamos a fonte utilizada no texto e definimos um 
        estilo para o t√≠tulo do v√≠deo, que al√©m do estilo do texto
        devem tamb√©m ser cortado na segunda linha se a ultrapassar
      */
      body{
        margin:0;
      }
      #videoTitle{
        color:#1a1a03;
        font-family:Roboto, Arial, sans-serif;
        font-weight:600;
        font-size:15px;      
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2; 
        -webkit-box-orient: vertical;
      }
    </style>
      <body xmlns="http://www.w3.org/1999/xhtml">
      <p id="videoTitle">
        Nenhum id definido
      </p>
      </body>
	  </foreignObject>
	</g>
	<!-- Data e visualiza√ß√µes -->
	<g transform="translate(0, 210)">
		<text fill="#606060" font-family="Roboto, Arial, sans-serif" font-weight="400" font-size="13px" id="viewsNDate">
			0 visualiza√ß√µes‚ÄÇ‚Ä¢‚ÄÇh√° 27 dias
		</text>
	</g>
  <!-- 
      Abaixo fica o nosso c√≥digo em javascript.
      A fun√ß√£o dele √© buscar informa√ß√µes no XML que o YouTube fornece e substituir 
      as informa√ß√µes do nosso layout acima e colocar informa√ß√µes que forem relevantes.
      
      Note que parece n√£o fazer sentido carregar aqui todos os dados novamente, j√° que os carregamos 
      l√° no README, mas o script utilizado tem algumas limita√ß√µes, como a busca por elementos que 
      est√£o dentro de outras tags no XML e, principalmente, pelo layout que queremos usar.
      
      Portanto, o que faremos neste caso √© apenas passar o canal (para a busca XML completa) e o
      id do v√≠deo que queremos (para compara√ß√£o ao filtrar os resultados)
    -->
  <script type="text/javascript">//<![CDATA[
      /*
        Esta √© a fun√ß√£o principal, que baixa as informa√ß√µes do YouTube e chama as fun√ß√µes que substituem
        os dados no desenho SVG. 

        Basicamente o XML √© baixado e:
        (i) a fun√ß√£o procura por cada registro (marcada no XML como uma "entry");
        (ii) em cada entry, procuramos pela tag yt:videoId;
        (iii) se essa videoId for igual √† videoId que recebemos neste arquivo, significa que a entrada 
        corresponde ao v√≠deo correto. Ent√£o, chamamos as fun√ß√µes que trocam as informa√ß√µes no SVG pelas 
        informa√ß√µes baixadas.

        E s√≥.
      */
      function getXMLData(request) {
          var xml = request.responseXML;
          var entries = xml.getElementsByTagName("entry");
          var found = false;
          for (var i = 0; i < entries.length && !found; i++) {
              var entry = entries[i];
              var currentVideoId = entry.getElementsByTagName("yt:videoId");
              if (currentVideoId[0].innerHTML === videoId) { // Encontramos o v√≠deo!
                  updateText("videoTitle", entry.getElementsByTagName("title")[0].innerHTML);
                  updateThumbnail(
                      "videoThumbnail",
                      "https://i.ytimg.com/vi/" + currentVideoId[0].innerHTML + "/mqdefault.jpg" // este √© o endere√ßo padr√£o que o YouTube usa para Thumbnails
                  );
                  // Vamos encontrar agora os dados de data de publica√ß√£o e contagem de visualiza√ß√µes
                  var publishedDate = entry.getElementsByTagName("published")[0].innerHTML;
                  var mediagroup = entry.getElementsByTagName("media:group")[0];
                  var mediacommunity = mediagroup.getElementsByTagName("media:community")[0];
                  var mediastats = mediacommunity.getElementsByTagName("media:statistics")[0];
                  var views = mediastats.getAttribute('views');
                  updateViewsNDate("viewsNDate", views, publishedDate);
                  found = true;
              }
          }
      }

      function updateText(tspanId, txt) {
          var spanEl = document.getElementById(tspanId);
          while (spanEl.firstChild) {
              spanEl.removeChild(spanEl.firstChild);
          }
          spanEl.appendChild(document.createTextNode(txt));
      }

      function updateThumbnail(tspanId, url) {
          var spanEl = document.getElementById(tspanId);
          spanEl.setAttribute("clip-path", url);
          spanEl.setAttribute("href", url);
      }

      function updateViewsNDate(tspanId, views, dateString) {
          var spanEl = document.getElementById(tspanId);
          while (spanEl.firstChild) {
              spanEl.removeChild(spanEl.firstChild);
          }
          spanEl.appendChild(document.createTextNode(views + ' visualiza√ß√µes‚ÄÇ‚Ä¢‚ÄÇ' + formatDate(dateString)));
      }
      /*
        Fun√ß√£o que serve para formatar uma data recebida no formato UTC (e.g. 2020-05-25T04:00:00Z)
        Para uma data mais amig√°vel para leitura humana.

        C√≥digo original acessado em https://css-tricks.com/how-to-convert-a-date-string-into-a-human-readable-format/
      */
      function formatDate(dateString) {
          const options = {
              year: "numeric",
              month: "long",
              day: "numeric"
          };
          return new Date(dateString).toLocaleDateString('pt-BR', options);
      };
      /*

            Vamos comentar aqui o que est√° sendo feito abaixo. Basicamente recebemos nesse arquivo
            duas informa√ß√µes para montar o nosso layout de v√≠deo: o ID do canal no YouTube e o ID do v√≠deo.

            - Com o ID do canal, baixamos do YouTube todo o XML com os detalhes de v√≠deos.
            - Com o ID do v√≠deo, filtramos o resultado acima at√© conseguir achar a correspond√™ncia.

          */

      const urlStr = window.location.href;
      const channelId = urlStr.replace(/.*channelId=([^&]*).*|(.*)/, '$1');
      const videoId = urlStr.replace(/.*videoId=([^&]*).*|(.*)/, '$1');

      /*
        Para fins do exemplo aqui, note que eu tive problemas em testar o c√≥digo abaixo no meu computador
        local (ou seja, simplesmente abrindo o arquivo index.html no meu navegador), recebendo um erro de CORS:

          Access to XMLHttpRequest at 'https://www.youtube.com/feeds/videos.xml?channel_id=UCPmM6RAkfC0CY2gGudIhWQA' 
          from origin 'null' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header contains 
          the invalid value 'null//undefined'.

          Esse erro ocorre pois o YouTube bloqueia o acesso da origem local. Para resolver isso, eu rodei 
          este arquivo a partir do VSCode, usando a extens√£o Live Server (clicando com o bot√£o direito no arquivo, 
          e selecionando a op√ß√£o "Open with Live Server"). Caso n√£o tenha visto e queira saber mais, veja o artigo 
          que fiz no blog sobre editores de c√≥digo, em que falo do VSCode e algumas extens√µes interessantes (dentre
          as quais o Live Server) üòÅ üîó https://br.dev.lawyer/2021/08/escolher-editor-codigo-programacao-web.html

          Neste c√≥digo, ap√≥s a requisi√ß√£o estar "pronta", chamamos a fun√ß√£o que vai baixar os dados importantes e 
          substitu√≠-los no desenho SVG.

          */
      var url = "https://www.youtube.com/feeds/videos.xml?channel_id=" + channelId;
      var xhttp = new XMLHttpRequest();
      xhttp.onreadystatechange = function() {
          if (this.readyState == 4 && this.status == 200) {
              getXMLData(this);
          }
      }
      xhttp.open("GET", url, true);
      xhttp.send();

      //]]>
  </script>  
</svg>